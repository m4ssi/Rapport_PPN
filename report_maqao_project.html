<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>MAQAO REPORT</title>
<!-- 2021-01-18 lun. 02:28 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Akli HAMITOUCHE - Amar HENNI - Amayas OUAKED - Imane KHELOUAT - Salem Aghiles BRAI" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">MAQAO REPORT</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. Présentation de l'outil MAQAO</a></li>
<li><a href="#sec-1-2">1.2. SIMD/Vectorisation</a></li>
<li><a href="#sec-1-3">1.3. Flags d'optimisation des compilateurs</a></li>
</ul>
</li>
<li><a href="#sec-2">2. ABC-MAQAO sur un cas simple : <b>dotprod</b></a>
<ul>
<li><a href="#sec-2-1">2.1. Chaine de production d'un binaire :</a></li>
<li><a href="#sec-2-2">2.2. Code source</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Makefile</a></li>
<li><a href="#sec-2-2-2">2.2.2. <b>dotprod.c</b></a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. Déroulement du processur d'optimisation</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. Etape initial : 00.dotprod</a></li>
<li><a href="#sec-2-3-2">2.3.2. Etapes intermediaires  : 01.dotprod &amp; 02.dotprod</a></li>
<li><a href="#sec-2-3-3">2.3.3. Etape finale : 03.dotprod</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. Obersations</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. Informations inexploitées</a></li>
<li><a href="#sec-2-4-2">2.4.2. Informations redondantes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Mini-Applications</a>
<ul>
<li><a href="#sec-3-1">3.1. HACC</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Résultat d'analyse : version de base</a></li>
<li><a href="#sec-3-1-2">3.1.2. Résultat d'analyse : version finale</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. miniqmc</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. Etape 1 :</a></li>
<li><a href="#sec-3-2-2">3.2.2. Etape 2 :</a></li>
<li><a href="#sec-3-2-3">3.2.3. Etape 3 :</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Conclusion</a>
<ul>
<li><a href="#sec-4-1">4.1. Perspective d'améliorations</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. Indiquer les options de compilations utilisés par binaire</a></li>
<li><a href="#sec-4-1-2">4.1.2. Redondance de suggestions</a></li>
<li><a href="#sec-4-1-3">4.1.3. Amélioration de l'affichage en textuel</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Bibliographie</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Présentation de l'outil MAQAO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>MAQAO</b> est un outil composé de trois principaux modules (LProf, CQA, ONE View), qui permet d’analyser et optimiser les performances 
de programmes HPC, il est indépendant du langage utilisé et il ne nécessite pas de recompilation grâce à sa capacité à fonctionner 
au niveau binaire, il est compatibles sur plusieurs architectures (intel, AMD Xeon Phi).
Il a pour objectif de guider les programmeurs à réaliser des applications optimisées en leur fournissant des rapports et des conseils 
détaillés tout au long du processus de développement.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> SIMD/Vectorisation</h3>
<div class="outline-text-3" id="text-1-2">
<p>
La vectorisation est un processus de conversion qui exécute des instructions SSE &amp; AVX et exploite des registres AVX et SSE, 
des extensions du jeu d’instructions SIMD des microprocesseurs x86, ces instructions sont utilisées de façon scalaire ou vectorielle 
et permettent de lancer simultanément plusieurs même instruction sur plusieurs données afin de produire les résultats attendus avec 
un coût d'exécution minimale.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Flags d'optimisation des compilateurs</h3>
<div class="outline-text-3" id="text-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Flags</th>
<th scope="col" class="left">Valeurs</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-g</td>
<td class="left">&#xa0;</td>
<td class="left">produit les informations de debug dans le format de l'OS</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">permet d'avoir le lien entre le binaire et le source</td>
</tr>

<tr>
<td class="left">-fnp-omit-frame-pointer</td>
<td class="left">&#xa0;</td>
<td class="left">permet d'avoir les callchains avec les options par défaut du profiler</td>
</tr>

<tr>
<td class="left">-O2</td>
<td class="left">&#xa0;</td>
<td class="left">produit un binaire légèrement optimisé</td>
</tr>

<tr>
<td class="left">-O3</td>
<td class="left">&#xa0;</td>
<td class="left">produit un binaire optimisé</td>
</tr>

<tr>
<td class="left">-Ofast</td>
<td class="left">&#xa0;</td>
<td class="left">produit un binaire fortement optimisé</td>
</tr>

<tr>
<td class="left">-funroll-loops</td>
<td class="left">&#xa0;</td>
<td class="left">force le déroulage des boucles</td>
</tr>

<tr>
<td class="left">-fassociative-math</td>
<td class="left">&#xa0;</td>
<td class="left">autorise la réassociatopn d'opérandes dans une série d'opération à virgule flottante</td>
</tr>

<tr>
<td class="left">-ftree-vectorize</td>
<td class="left">&#xa0;</td>
<td class="left">effectue la vectorisation de boucle sur les arbres ? : activé par défaut avec -O3</td>
</tr>

<tr>
<td class="left">-floop-unroll-and-jam</td>
<td class="left">&#xa0;</td>
<td class="left">non trouvée dans le manuel de GCC</td>
</tr>

<tr>
<td class="left">-march=</td>
<td class="left">native</td>
<td class="left">indique au compilateur de produire un binaire qui correspond</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">core-avx2</td>
<td class="left">au processeur d'exécution du code</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">x86-64</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">-mtune=</td>
<td class="left">native</td>
<td class="left">génère un code optimisé pour l'architecture cible tout en garantissant</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">une retro-coçmpatibilité</td>
</tr>

<tr>
<td class="left">-finline-functions</td>
<td class="left">&#xa0;</td>
<td class="left">inline toutes les fonctions simples</td>
</tr>

<tr>
<td class="left">-flto</td>
<td class="left">&#xa0;</td>
<td class="left">exécute l'optimiseur de temps de liaison</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ABC-MAQAO sur un cas simple : <b>dotprod</b></h2>
<div class="outline-text-2" id="text-2">
<p>
Afin de réaliser ce projet, une étape clé était de comprendre et d'apprendre à utiliser <b>MAQAO</b>. Pour cela, nous avons cherché à optimiser un
benchmark deja vu en cours : le <b>dotprod</b>. L'idée était de faire le travail d'optimisation un maximum de fois depuis la version de base afin 
d'identifier les informations récurrentes et exploitable qui nous étaient produites. Une fois ces sections identifiées, une chaine de production
d'un binaire (processus d'optimisation) a été mise en place et expliqué dans cette section.
</p>

<p>
Les résultats obtenus lors de cette analyse peuvent être retrouvés sur ce dépôt : <i><a href="https://github.com/m4ssi/Dotprod">https://github.com/m4ssi/Dotprod</a></i>
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Chaine de production d'un binaire :</h3>
<div class="outline-text-3" id="text-2-1">
<p>
La chaine de production mise en oeuvre, schématisée par la figure 1, se déroule telle que :
</p>

<ol class="org-ol">
<li>Compilation sans options de compilation
</li>
<li>Analyse du binaire obtenu 
</li>
<li>Recompilation du programme avec les options suggérés et avec O2, O3 ou Ofast (généralement Ofast - passage en 7)
</li>
<li>Analyse des trois binaire obtenu
</li>
<li>Si les suggestions faites sont differentes pour les trois : retour en 3
</li>
<li>Sinon : choix du meilleur flags (compromis entre le temps d'exécution et taille du binaire) puis 7
</li>
<li>Application des recommandations et analyse jusqu'a trouver une limite


<div id="fig:-optimization_process" class="figure">
<p><img src="./img/inter_process.png" alt="inter_process.png" width="600px" />
</p>
<p><span class="figure-number">Figure 1:</span> Processur iteratif d'optimisation à l'aide de MAQAO</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Code source</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Makefile</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Comme on peut le voir sur le Makefile suivant, notre programme est compilé sans aucune optimisation
afin de commencer notre analyse depuis le début.
</p>

<div class="org-src-container">

<pre class="src src-make">all: 00.dotprod

00.dotprod:
	gcc -Wall -g -fno-omit-frame-pointer -O0 -o $@ $@.c
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> <b>dotprod.c</b></h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Une particularité du dotprod ci-après présenté est qu'il nous permet de fixer une taille de vecteur en Bytes
et de boucler sur la fonciton principale afin de pouvoir jouer sur le temps d'exécution de notre programme d'une part
et ainsi mieux voir la performance gagné.
</p>

<div class="org-src-container">

<pre class="src src-c">double dotprod(double *restrict a, double *restrict b, unsigned long long n)    {
	double d = 0.0;
	for ( unsigned long long i = 0; i &lt; n; i++)
		d += a[i] * b[i];
	return d;       
}

void fill_vector (double *restrict vect, unsigned long long n)  {
	for (unsigned long long i = 0; i &lt; n; i++)
		vect[i] = 1;
}

int main ( int argc, char ** argv)      {
	if ( argc == 1) return 1;

	// Size of vectors
	unsigned long long n = atoll ( argv[1]);
	unsigned long long n_b = n/sizeof(double);

	// Allocate memory for vectors
	double  * a = malloc ( n),
		* b = malloc ( n),
		res = 0.0;

	// Init vector values           
	fill_vector ( a, n_b);
	fill_vector ( b, n_b);


	// Doing a dotprod
	for ( int i = 0; i &lt; 10000; i++)
		res = dotprod ( a, b, n_b);


	// Free memory
	free ( a);
	free ( b);

	// Print dotprod result
	printf ("Res : %lf\n", res);

	return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Déroulement du processur d'optimisation</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Etape initial : 00.dotprod</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
En premier lieu, on effecture une analyse du binaire obtenu avec uniquement les flags permettant à <b>MAQAO</b> de faire son analyse. On exploite alors
les informations mises à notre disposition afin d'améliorer les performances de notre programme dans l'ordre suivant : 
</p>


<p>
Il est important de préciser que notre programme ne possède que deux boucles à optimiser et que les améliorations à faire sur la 2e boucle sont les mêmes que sur la première.
L'application des améliorations vont nous permettre d'aboutir à la version 01.dotprod.
</p>
</div>
<ol class="org-ol"><li><a id="sec-2-3-1-1" name="sec-2-3-1-1"></a>Index<br  /><div class="outline-text-5" id="text-2-3-1-1">
<p>
On commence notre analyse par la page d'accueil du rapport. Sur cette page, on retrouve des informations préliminaires qui nous permettent de savoir
si un processus d'optimisation pourra nous permettre de gagner en performance ou non.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-3-1-1-1" name="sec-2-3-1-1-1"></a>Global Metrics<br  /><div class="outline-text-6" id="text-2-3-1-1-1">

<div id="fig:-initial_global_metrics" class="figure">
<p><img src="./img/dotprod/00.dotprod/global.png" alt="global.png" width="300px" />
</p>
<p><span class="figure-number">Figure 2:</span> Rubrique 'Global Metrics' initial</p>
</div>

<p>
En observant les métriques globales du binaire analysé, on constate que celui-ci a été compilé sans flags d'optimisation ni de flags de spécification d'architecture.
De plus, on voit que d'une part, nos accès mémoire sont efficaces à 75% (la valeur est bonne mais pourrait être amélioré) et des speed-up peuvent-être otbtenus si le
programme est vectorisé à la compilation. Les possibilités d'améliorations seront présentées ultérieurement dans la rubrique <b>LOOPS</b> contenant l'essentiel des améliorations
suggéré.
</p>

<p>
A cette étape, nous allons prendre en compte la suggestion des flags [O2, O3, Ofast], -march=target et -funroll-loops pour le prochain binaire à produire.
</p>
</div>
</li>
<li><a id="sec-2-3-1-1-2" name="sec-2-3-1-1-2"></a>Experiment Summary<br  /><div class="outline-text-6" id="text-2-3-1-1-2">

<div id="fig:-initial_experiment_summary" class="figure">
<p><img src="./img/dotprod/00.dotprod/summary.png" alt="summary.png" width="500px" />
</p>
<p><span class="figure-number">Figure 3:</span> Rubrique 'Experiment Summary' initial</p>
</div>

<p>
A l'étape initiale, cette section ne nous est pas d'une grande utilité si ce n'est nous indiqué la micro-architecture de la machine cible ainsi que les flags que <b>gcc</b> ajoute
à notre place. Notre que la section précédente nous indiquait que l'option -march était manquant alors que celle-ci nous indique que -march=x86-64 a été indiquée.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-2-3-1-2" name="sec-2-3-1-2"></a>Application<br  /><div class="outline-text-5" id="text-2-3-1-2">
<p>
La section Application et plus particulièrement Detailed Application Categorization nous indique la couverture des différentes partie de notre code (code utilisateur, noyau, librairie externe, maths, etc &#x2026;)
Elle nous permet d'avoir une première évaluation de la portion de code réellement optimisable (généralement Binary et Math) via les suggestions d'optimisation du module <b>CQA</b>
</p>


<div id="fig:-initial_application-Categorization" class="figure">
<p><img src="./img/dotprod/00.dotprod/application.png" alt="application.png" width="500px" />
</p>
<p><span class="figure-number">Figure 4:</span> Detailed Application Categorization</p>
</div>

<p>
Dans le cas du dotprod avec des vecteurs mis à 1, la totalité du programme s'exécute au niveau du code utilisateur.
</p>
</div>
</li>

<li><a id="sec-2-3-1-3" name="sec-2-3-1-3"></a>LOOPS<br  /><div class="outline-text-5" id="text-2-3-1-3">
<p>
Maintenant que nous savons que notre code est optimisable et que les speed-ups potentiels sont interessant, nous allons nous intéresser au boucles à améliorer
et pouvoir découvrir les amélirations possibles.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-3-1-3-1" name="sec-2-3-1-3-1"></a>Loops index<br  /><div class="outline-text-6" id="text-2-3-1-3-1">
<p>
On regarde tout d'abord un tableau récapitulatif les boucles que nous devrons optimiser et pour mieux guider nos améliration (fixer une echelle de priorité pour un code possedant
plusieurs boucles à optimiser), on affiche le temps d'exécution de chacun ainsi que les speed-ups sur les types d'améliorationsa faire, suivant que les résultats affichés par le
tableau global. On choisit donc d'afficher les speed-ups si FP vectorisé et Totalement vectorisé.
</p>


<div id="fig:-initial_loops_index" class="figure">
<p><img src="./img/dotprod/00.dotprod/loops_index.png" alt="loops_index.png" width="900px" />
</p>
<p><span class="figure-number">Figure 5:</span> Initial Loops Index</p>
</div>

<p>
On constate qu'une boucle à une couverture de 99% et on décide donc de commencer par celle-la. On affiche donc son rapport <b>CQA</b>
</p>
</div>
</li></ol>
</li>

<li><a id="sec-2-3-1-4" name="sec-2-3-1-4"></a>Rapport <b>CQA</b><br  /><div class="outline-text-5" id="text-2-3-1-4">
<p>
Le rapport CQA se présente comme le montre la figure suivante :
</p>


<div id="fig:-cqa_loop_0" class="figure">
<p><img src="./img/dotprod/00.dotprod/cqa_main.png" alt="cqa_main.png" width="500px" />
</p>
<p><span class="figure-number">Figure 6:</span> Rapport CQA de la boucle Loop<sub>0</sub></p>
</div>

<p>
On peut voir le code source de la boucle sur la gauche et les améliorations a effectuer dessus sur la droite. Nous allons réaliser chacune des
modificatoins demandée lorsque cela est possible afin de pouvoir constater dans une analyse ultérieur si notre programme est optimisé.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-3-1-4-1" name="sec-2-3-1-4-1"></a>Gain : Code clean check<br  /><div class="outline-text-6" id="text-2-3-1-4-1">
<p>
Un motif de perte de performance que nous avons pu observer sur la totalité des programmes analysés (écrits en C/C++) est la présence
d'instructions scalaires sur entier généralement causées par le calcul d'adressage. Nous decidons donc de ne plus utiliser l'opérateur []
au profit du déréférencement de pointeur ( a[i] devient *(a+i)). 
</p>


<div id="fig:-initial_clean_check" class="figure">
<p><img src="./img/dotprod/00.dotprod/code_clean_check.png" alt="code_clean_check.png" width="500px" />
</p>
<p><span class="figure-number">Figure 7:</span> Gain - Code clean check</p>
</div>
</div>
</li>

<li><a id="sec-2-3-1-4-2" name="sec-2-3-1-4-2"></a>Gain : Vectorization<br  /><div class="outline-text-6" id="text-2-3-1-4-2">
<p>
En plus de nous indiquer la points de perte de performance, il nous est aussi proposé d'améliorer notre programme en recourant à la vectorisation.
Cette section se compose d'un constat sur le taux de vectorisaton (de pas du tout vectorisé à totalement vectorisé), une explication sur la vectorisatoin
et les instructions utilisées ainsi que le travail à faire. Nous prenons donc en compte pour notre prochaine compilation les flags <b>ftree-vectorize</b> et <b>fassociative-math</b>,
bien que présente dans les options O3 et Ofast.
</p>

<div id="fig:-initial_vecto_gain" class="figure">
<p><img src="./img/dotprod/00.dotprod/vectorization.png" alt="vectorization.png" width="500px" />
</p>
<p><span class="figure-number">Figure 8:</span> Gain - Vectorization</p>
</div>

<p>
Notons pour cette section, l'information sur les dépendances inter-iterations ne nous est d'aucune utilisé et n'est donc pas exploitable.
</p>
</div>
</li>

<li><a id="sec-2-3-1-4-3" name="sec-2-3-1-4-3"></a>Potential : FMA<br  /><div class="outline-text-6" id="text-2-3-1-4-3">
<p>
Une autre force de MAQAO est de détecter la présence d'aditions/soustractoins et de multiplications et nous invite donc à changer la synthaxe de
notre operation d'accumulation et avoir un gain de performance. Cette section nous permet également de savoir a quel point le code est vectorisé : 
plus il y aura d'operation FMA et plus les registres SSE/AVX sont utilisés.
</p>

<p>
Pour la suite, on décide donc de remplacer les operations a + b * c par a + (b + c) et d'ajouter l'option <b>-march=core-avx2</b>.
</p>

<div id="fig:-initial_fma" class="figure">
<p><img src="./img/dotprod/00.dotprod/fma.png" alt="fma.png" width="500px" />
</p>
<p><span class="figure-number">Figure 9:</span> Potential - FMA</p>
</div>
</div>
</li>

<li><a id="sec-2-3-1-4-4" name="sec-2-3-1-4-4"></a>Hint : Unroll opportunity<br  /><div class="outline-text-6" id="text-2-3-1-4-4">
<p>
Un dernier point important que nous cherchons systématiquement a voir est l'opportunité de déroulage de boucles. Ceci peut se faire en conjuguant un déroulage
manuel et l'ajout des options <b>-funroll-loops</b> et/ou <b>-floop-unroll-and-jam</b>.
</p>


<div id="fig:-initial_unroll" class="figure">
<p><img src="./img/dotprod/00.dotprod/unroll_opportunity.png" alt="unroll_opportunity.png" width="500px" />
</p>
<p><span class="figure-number">Figure 10:</span> Gain - Unroll opportunity</p>
</div>
</div>
</li></ol>
</li></ol>
</div>


<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> Etapes intermediaires  : 01.dotprod &amp; 02.dotprod</h4>
<div class="outline-text-4" id="text-2-3-2">
</div><ol class="org-ol"><li><a id="sec-2-3-2-1" name="sec-2-3-2-1"></a>01.dotprod<br  /><div class="outline-text-5" id="text-2-3-2-1">
<p>
Dans cette version, on remarque une nette amélioration de notre programme : nous passons d'un temps d'exécution de 4.14 secondes à 1.3 secondes
avec une meilleurs efficactiés de nos accès mémoire (100%). Cette amélioration est confirmé par le speed-up potentiel de 1.33 si on arrive a totalement
vectoriser notre programme. On remarque également que l'une des boucles de notre programme n'est pas disponnible sur notre rapport. On en déduit qu'elle
a été optimisé au maximum et que le travail restant ne s'effectuera que sur une seul boucle. A noter que des améliorations peuvent être possible .
A cette étape, notre programme reçoit les modifications présentées ci-après :
</p>

<div class="org-src-container">

<pre class="src src-c">double dotprod(double *restrict a, double *restrict b, unsigned long long n)    {
	double d = 0.0;
	for ( unsigned long long i = 0; i &lt; n; i+=4)    {
		d += ( *(a+i) * *(b+i) );
		d += ( *(a+i+1) * *(b+i+1) );
		d += ( *(a+i+2) * *(b+i+2) );
		d += ( *(a+i+3) * *(b+i+3) );
	}
	return d;       
}

void fill_vector (double *restrict vect, unsigned long long n)  {
	for (unsigned long long i = 0; i &lt; n; i+=4)     {
		*(vect+i) = 1;
		*(vect+i+1) = 1;
		*(vect+i+2) = 1;
		*(vect+i+3) = 1;
	}
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-2-3-2-1-1" name="sec-2-3-2-1-1"></a>Rapport sur la version 01 et améliorations constatés<br  /><div class="outline-text-6" id="text-2-3-2-1-1">

<div id="fig:-01.dotprod_global_metrics" class="figure">
<p><img src="./img/dotprod/01.dotprod/global.png" alt="global.png" width="300px" />
</p>
<p><span class="figure-number">Figure 11:</span> Rubrique 'Global Metrics' 01.dotprod</p>
</div>


<div id="fig:-01.dotprod_loops_index" class="figure">
<p><img src="./img/dotprod/01.dotprod/loops_index.png" alt="loops_index.png" width="900px" />
</p>
<p><span class="figure-number">Figure 12:</span> Rubrique 'Loops index' 01.dotprod</p>
</div>
</div>
</li>

<li><a id="sec-2-3-2-1-2" name="sec-2-3-2-1-2"></a>Amélioration à apporter<br  /><div class="outline-text-6" id="text-2-3-2-1-2">
<p>
D'après les sections du rapport suivante, on se rend compte que notre programme est vectorisé mais pas totalement. Ce problème vient du fait que notre
mémoire n'est pas alignée et nous applicons donc la suggestion d'utiliser la fonction <b>posix<sub>memalign</sub></b>. Nous décidons également d'enrouler la boucle du dotprod 
afin de voir l'effet que ça aura sur la vectorisation.
</p>


<div id="fig:-01.dotprod_vecto" class="figure">
<p><img src="./img/dotprod/01.dotprod/vectorization.png" alt="vectorization.png" width="500px" />
</p>
<p><span class="figure-number">Figure 13:</span> 01.dotprod : Taux de vectorisation</p>
</div>


<div id="fig:-01.dotprod_unaligned" class="figure">
<p><img src="./img/dotprod/01.dotprod/unaligned_vector.png" alt="unaligned_vector.png" width="500px" />
</p>
<p><span class="figure-number">Figure 14:</span> 01.dotprod : Vecteur non-alignés</p>
</div>
</div>
</li></ol>
</li>


<li><a id="sec-2-3-2-2" name="sec-2-3-2-2"></a>02.dotprod<br  /><div class="outline-text-5" id="text-2-3-2-2">
<p>
Arrivé a cette étape, les principaux changement de notre code source sont les suivants : utilisation de <b>posix_memalign</b> et enroulement d'une boucle
comme le montre le listing suivant :
</p>

<div class="org-src-container">

<pre class="src src-c">double dotprod(double *restrict a, double *restrict b, unsigned long long n)    {
	double d = 0.0;
	for ( unsigned long long i = 0; i &lt; n; i+=2)    {
		d += ( *(a+i) * *(b+i) );
		d += ( *(a+i+1) * *(b+i+1) );
		//~ d += ( *(a+i+2) * *(b+i+2) );
		//~ d += ( *(a+i+3) * *(b+i+3) );
	}
	return d;       
}

int main ( int argc, char ** argv)      {
	// Size of vectors
	...
	// Allocate memory for vectors
	double  * p_a = NULL,
			* p_b = NULL;
	int ret = 0;
	ret +=posix_memalign ((void **)  &amp;p_a, 32, n);
	ret += posix_memalign ((void **) &amp;p_b, 32, n);
	if ( ret) return 2;             
	double  * a = __builtin_assume_aligned(p_a, 32),
			* b = __builtin_assume_aligned(p_b, 32),
			res = 0.0;      
	// Init vector values           
	...
	// Doing a dotprod
	...
	// Free memory
	...
	return 0;
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-2-3-2-2-1" name="sec-2-3-2-2-1"></a>Rapport sur la version 02 et améliorations constatés<br  /><div class="outline-text-6" id="text-2-3-2-2-1">
<p>
A notre grande surprise, la version déroulée deux fois est plus optimale que la version déroulée quatre fois. Nous allons donc réessayer une nouvelle
fois sans déroulage de boucle et ainsi voir l'effet que ça pourrait avoir vu qu'on a deja eu un effet positif en réduisant le déroulage.
</p>


<div id="fig:-02.dotprod_global_metrics" class="figure">
<p><img src="./img/dotprod/02.dotprod/global_4.png" alt="global_4.png" width="300px" />
</p>
<p><span class="figure-number">Figure 15:</span> Rubrique 'Global Metrics' 02.dotprod déroulé 4 fois</p>
</div>


<div id="fig:-02.dotprod_fma" class="figure">
<p><img src="./img/dotprod/02.dotprod/global_2.png" alt="global_2.png" width="300px" />
</p>
<p><span class="figure-number">Figure 16:</span> Rubrique 'Global Metrics' 02.dotprod déroulé 2 fois</p>
</div>
</div>
</li>

<li><a id="sec-2-3-2-2-2" name="sec-2-3-2-2-2"></a>Amélioration à apporter<br  /><div class="outline-text-6" id="text-2-3-2-2-2">
<p>
On constate encore une fois que notre boucle n'est toujours pas vectorisé totalement. On peut donc conclure que nous avons atteint notre limite d'optimisation.
Cependant nous allons faire un dernier test et voir qu'une heuristique peu nous conduire à une meilleur version.
</p>

<div id="fig:-01.dotprod_vecto" class="figure">
<p><img src="./img/dotprod/02.dotprod/vectorization.png" alt="vectorization.png" width="500px" />
</p>
<p><span class="figure-number">Figure 17:</span> 01.dotprod : Taux de vectorisation</p>
</div>

<p>
A noter que la fonction suggéré par <b>MAQAO</b> dans cette capture a déjà été utilisé et constitue donc une redondance d'information a supprimer ou que l'utilisateur
devrait pouvoir indiquer que cette fonction a été utilisé pour que <b>MAQAO</b> le prenne en compte et ne plus suggérer l'utilisation de cette fonction.
</p>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> Etape finale : 03.dotprod</h4>
<div class="outline-text-4" id="text-2-3-3">
</div><ol class="org-ol"><li><a id="sec-2-3-3-1" name="sec-2-3-3-1"></a>Rapports obtenus<br  /><div class="outline-text-5" id="text-2-3-3-1">
<p>
Arrivé au dernier rapport, on voit clairement que notre programme est totalement vectorisé et est au plus efficace possible : gain de temps d'exécution constaté
par rapport a toutes les versions précédentes et utilisation de tous les registres SSE/AVX. Nous avons donc ainsi atteint le meilleur code possible avec les meilleurs
options d'optimisation possible pour le dotprod.
</p>


<div id="fig:-final_global_metrics" class="figure">
<p><img src="./img/dotprod/03.dotprod/last_global.png" alt="last_global.png" width="300px" />
</p>
<p><span class="figure-number">Figure 18:</span> Rubrique 'Global Metrics' finale</p>
</div>


<div id="fig:-final_index" class="figure">
<p><img src="./img/dotprod/03.dotprod/last_loops_index.png" alt="last_loops_index.png" width="900px" />
</p>
<p><span class="figure-number">Figure 19:</span> 'Loops Index' finale</p>
</div>


<div id="fig:-last_cqa" class="figure">
<p><img src="./img/dotprod/03.dotprod/last_gain.png" alt="last_gain.png" width="500px" />
</p>
<p><span class="figure-number">Figure 20:</span> Dernier rapport CQA</p>
</div>


<div id="fig:-proof_vecto" class="figure">
<p><img src="./img/dotprod/03.dotprod/proof_vecto.png" alt="proof_vecto.png" width="500px" />
</p>
<p><span class="figure-number">Figure 21:</span> Preuve de la vectorisation</p>
</div>
</div>
</li>


<li><a id="sec-2-3-3-2" name="sec-2-3-3-2"></a>Makefile<br  /><div class="outline-text-5" id="text-2-3-3-2">
<div class="org-src-container">

<pre class="src src-make">all: 03.dotprod

03.dotprod:
	gcc -Wall -g -fno-omit-frame-pointer -Ofast -march=native -funroll-loops -floop-unroll-and-jam -ftree-vectorize -fassociative-math -march=core-avx2 -o $@ $@.c
</pre>
</div>
</div>
</li>

<li><a id="sec-2-3-3-3" name="sec-2-3-3-3"></a><b>dotprod.c</b><br  /><div class="outline-text-5" id="text-2-3-3-3">
<div class="org-src-container">

<pre class="src src-c">double dotprod(double *restrict a, double *restrict b, unsigned long long n)    {
	double d = 0.0;
	for ( unsigned long long i = 0; i &lt; n; i++)     {
		d += ( *(a+i) * *(b+i) );
	}
	return d;       
}

void fill_vector (double *restrict vect, unsigned long long n)  {
	for (unsigned long long i = 0; i &lt; n; i+=4)     {
		*(vect+i) = 1;
		*(vect+i+1) = 1;
		*(vect+i+2) = 1;
		*(vect+i+3) = 1;
	}
}

int main ( int argc, char ** argv)      {
	if ( argc == 1) return 1;

	// Size of vectors
	unsigned long long n = atoll ( argv[1]);
	unsigned long long n_b = n/sizeof(double);

	printf ("%llu\n", n);

	// Allocate memory for vectors
	double  * p_a = NULL,
		* p_b = NULL;
	int ret = 0;
	ret +=posix_memalign ((void **)  &amp;p_a, 32, n);
	ret += posix_memalign ((void **) &amp;p_b, 32, n);
	if ( ret) return 2;             
	double  * a = __builtin_assume_aligned(p_a, 32),
		* b = __builtin_assume_aligned(p_b, 32),
		res = 0.0;

	// Init vector values           
	fill_vector ( a, n_b);
	fill_vector ( b, n_b);


	// Doing a dotprod
	for ( int i = 0; i &lt; 10000; i++)
		res = dotprod ( a, b, n_b);


	// Free memory
	free ( a);
	free ( b);

	// Print dotprod result
	printf ("Res : %lf\n", res);

	return 0;
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>


<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Obersations</h3>
<div class="outline-text-3" id="text-2-4">
<p>
On constate au cours de l'analyse que certaines informations pouvaient se montrer redondantes et d'autres inexploitable à notre échelle et sont exposées
ci-après :
</p>
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Informations inexploitées</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Dans cette section, nous présentons les captures des informations sur les types d'instruction et nombre d'instructions utilisés que nous n'avons pas pu exploiter
dans notre processus iteratif.
</p>


<div id="fig:-useless0" class="figure">
<p><img src="./img/dotprod/00.dotprod/useless0.png" alt="useless0.png" width="500px" />
</p>
<p><span class="figure-number">Figure 22:</span> Ensemble d'informations inexploité lors du premier run</p>
</div>


<div id="fig:-useless1" class="figure">
<p><img src="./img/dotprod/00.dotprod/useless1.png" alt="useless1.png" width="500px" />
</p>
<p><span class="figure-number">Figure 23:</span> Ensemble d'informations inexploité lors du premier run</p>
</div>


<div id="fig:-useless0" class="figure">
<p><img src="./img/dotprod/01.dotprod/useless0.png" alt="useless0.png" width="500px" />
</p>
<p><span class="figure-number">Figure 24:</span> Ensemble d'informations inexploité lors du deuxième run</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Informations redondantes</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
Dans cette section, on montre des informations qui ont été affichées plusieurs fois alors qu'elles avaient préalablement prise en compte (cas de posix_memealign)
ainsi que d'autres qui n'ont pas pu nous aider à optimiser notre programme (cas du unroll loops qui nous a empéché d'atteindre la vectorisation totale). 
</p>


<div id="fig:-01.dotprod_vecto" class="figure">
<p><img src="./img/dotprod/02.dotprod/vectorization.png" alt="vectorization.png" width="500px" />
</p>
<p><span class="figure-number">Figure 25:</span> 01.dotprod : Taux de vectorisation</p>
</div>


<div id="fig:-useless0" class="figure">
<p><img src="./img/dotprod/03.dotprod/useless_unroll.png" alt="useless_unroll.png" width="500px" />
</p>
<p><span class="figure-number">Figure 26:</span> Unroll Loops</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Mini-Applications</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> HACC</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Résultat d'analyse : version de base</h4>
<div class="outline-text-4" id="text-3-1-1">

<div id="fig:-glob_init_hacc" class="figure">
<p><img src="./img/HACC/global_init.png" alt="global_init.png" width="300px" />
</p>
<p><span class="figure-number">Figure 27:</span> 'Global Metrics' HACC initial</p>
</div>


<div id="fig:-app_init_hacc" class="figure">
<p><img src="./img/HACC/application_init.png" alt="application_init.png" width="900px" />
</p>
<p><span class="figure-number">Figure 28:</span> Application HACC initial</p>
</div>


<div id="fig:-loops_init_hacc" class="figure">
<p><img src="./img/HACC/loop_index_init.png" alt="loop_index_init.png" width="900px" />
</p>
<p><span class="figure-number">Figure 29:</span> 'Loops Index' HACC initial</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Résultat d'analyse : version finale</h4>
<div class="outline-text-4" id="text-3-1-2">

<div id="fig:-glob_final_hacc" class="figure">
<p><img src="./img/HACC/global_last.png" alt="global_last.png" width="300px" />
</p>
<p><span class="figure-number">Figure 30:</span> 'Global Metrics' HACC final</p>
</div>


<div id="fig:-app_final_hacc" class="figure">
<p><img src="./img/HACC/application_init.png" alt="application_init.png" width="900px" />
</p>
<p><span class="figure-number">Figure 31:</span> Application HACC final</p>
</div>


<div id="fig:-loops_final_hacc" class="figure">
<p><img src="./img/HACC/loop_index_last.png" alt="loop_index_last.png" width="900px" />
</p>
<p><span class="figure-number">Figure 32:</span> 'Loops Index' HACC final</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> miniqmc</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Ce benchmark est une partie simplifiée de QMCPACK1, il contient 
une implémentation précise simplifiée de côté calcul d’algorithmes quantiques 
de Monte Carlo dans l'espace réel.
</p>

<p>
Exemple d’utilisation : vérification de la performance des GPU d’Intel.
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Etape 1 :</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Nous avons effectué une modification dans le CMakeLists.txt de miniQMC en ajoutant l’option de debugage suivante :
-“ SET(CMAKE_BUILD_TYPE debug) ”, la figure ci-dessous nous montre les résultats obtenus.
</p>


<div id="fig:-global_qmc_init" class="figure">
<p><img src="./img/miniqmc/global_init.png" alt="global_init.png" width="300px" />
</p>
<p><span class="figure-number">Figure 33:</span> 'Global Metrics' miniqmc initial</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Etape 2 :</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Nous avons ajouté add_compile_options(-O2) dans le CMakeLists.txt, on a obtenu les résultats suivants :
</p>


<div id="fig:-global_qmc_init" class="figure">
<p><img src="./img/miniqmc/global_final.png" alt="global_final.png" width="300px" />
</p>
<p><span class="figure-number">Figure 34:</span> 'Global Metrics' miniqmc</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Etape 3 :</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Maintenant que nous avons validé les options de compilation ainsi que les speed-ups potentiels, 
nous allons passer au volet loop ou on remarque qu’il y a une  boucle qui a une couverture de  31.78 % 
</p>


<div id="fig:-index_qmc_init" class="figure">
<p><img src="./img/miniqmc/loops_index_0.png" alt="loops_index_0.png" width="900px" />
</p>
<p><span class="figure-number">Figure 35:</span> 'Loops Index' miniqmc</p>
</div>

<p>
En regardant de plus  près les messages laissées au niveau du rapport CQA, ce dernier nous dit que cette boucle n’est pas vectorisée :
</p>



<div id="fig:-global_qmc_init" class="figure">
<p><img src="./img/miniqmc/vecto2.png" alt="vecto2.png" width="600px" />
</p>
<p><span class="figure-number">Figure 36:</span> Vectorisation de miniqmc</p>
</div>

<p>
De ce fait on a utilisé plus d’option de compilation afin de pouvoir vectoriser le plus possible cette dernière, après plusieurs tentative on a conclu qu’avec la suite de flag suivante était celle qui vectorise le plus :
2OMAX = -march=native -mtune=native -Ofast -funroll-loops 
</p>


<div id="fig:-index_qmc" class="figure">
<p><img src="./img/miniqmc/loops_index_0.png" alt="loops_index_0.png" width="900px" />
</p>
<p><span class="figure-number">Figure 37:</span> 'Loops Indexs' miniqmc</p>
</div>

<p>
On remarque qu’on a réussi à vectorisé la boucle, on est passer d’une couverture de 31.78% à une couverture de 0.48 %  
</p>


<div id="fig:-global_qmc_init" class="figure">
<p><img src="./img/miniqmc/vecto.png" alt="vecto.png" width="600px" />
</p>
<p><span class="figure-number">Figure 38:</span> Vectorisation de miniqmc</p>
</div>

<p>
Afin de bien visualiser et comparer  les runs qu'on a fait avec différents flag d’optimisation, on a résumé les valeurs obtenu dans le tableau ci-dessous : 
</p>


<div id="fig:-tab_qmc" class="figure">
<p><img src="./img/miniqmc/tab.png" alt="tab.png" width="700px" />
</p>
<p><span class="figure-number">Figure 39:</span> Tableau recapitulatif des exécution de miniqmc</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Conclusion</h2>
<div class="outline-text-2" id="text-4">
<p>
Le principal objectif de ce projet étant de trouver des améliorations pour <b>MAQAO</b> et non améliorer les applications, ce document, qui se trouve
être un rapport sur comment un groupe d'étudiant à du se familiariser avec, s'en servir pour optimiser des programmes ainsi que d'apprendre de 
nouvelles techniques de programmation, constitue un feed-back et pourrait permettre des améliorations en analysant nos apprioris et postulats.
</p>

<p>
A cela s'ajoute des suggestions qui nous sont venues lors du processus iteratif, énuméré ci-après:
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Perspective d'améliorations</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Indiquer les options de compilations utilisés par binaire</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Lors de l'analyse du programme <b>HACC</b>, on a du compiler séparement 3 fichiers. Pour avancer progressivement dans on amélioratoin, on s'est concentré sur un seul ficher
dans un premier lieu. On s'est alors rendu compte que <b>MAQAO</b> indiquait "OK" pour les options de compilations alors que seul le fichier Step10<sub>orig</sub>.c a reçu ce flag.
Pour un programme modulaire ayant plusieurs fonctions réparties sur plusieurs fichiers ne necessitant pas les mêmes options de compilation, il devient interessant 
de savoir quel fichier a reçu quel option.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Redondance de suggestions</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Une autre remarque se basant sur une observation sur le <b>dotprod</b> et <b>HACC</b> est qu'une même suggestion peut revenir pour plusieurs boucles et qu'au sein d'une même boucle
on se retrouve avec une même suggestion relative à l'alignement (utilisation de posix<sub>memealign</sub>). Il devient alors utile de pouvoir avoir une section/rubrique "Works around"
ou "Mutual suggestions" qui mutualise les mêmes optimisations applicable à un ensemble de boucles. Cela rendrait la lecture plus simple et permetterait d'optimiser plus vite
une application telle que <b>miniqmc</b> qui présente un très grand nombre de boucle optimisable.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> Amélioration de l'affichage en textuel</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
La dernière remarque la plus importante que nous pouvons formuler est que <b>MAQAO</b> est extrémement gourmant en ressource. On constate souvent que l'interface grapique se fige le
temps d'une analyse. Pour résoudre ce problème et permettre a nos analyse d'aller plus vite, une idée simple étant de désactiver l'interface graphique de nos machins. Cependant,
en mode console, à moins de tout le temps rediriger la sortie standard vers un fichier pour pouvoir reconsulter nos résultats, l'affichage est très vite perdu et la lecture de fichiers
html en console devient pénible. Une idée était donc de reformater la sortie textuelle de <b>MAQAO</b> pour obtenir un fichier en org-mode, plus facilement exploitable au mode console,
emacs integrant la prise en charges de fichiers en orgmode. Un parseur a donc été écrit en C++ afin de pouvoir générer un rapport en orgmode à l'aide de la fonction <b>popen</b> ainsi qu'une relative
bonne connaissance du format textuel de <b>MAQAO</b> et des informations affichées. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Bibliographie</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li><a href="http://www.maqao.org/">http://www.maqao.org/</a>
</li>
<li><a href="http://www.maqao.org/release/MAQAO_QuickReferenceSheet_V9.pdf">http://www.maqao.org/release/MAQAO_QuickReferenceSheet_V9.pdf</a>
</li>
<li><a href="http://www.maqao.org/release/MAQAO.Tutorial.ONEVIEW.pdf">http://www.maqao.org/release/MAQAO.Tutorial.ONEVIEW.pdf</a>
</li>
<li><a href="https://fr.wikipedia.org/wiki/Streaming_SIMD_Extensions">https://fr.wikipedia.org/wiki/Streaming_SIMD_Extensions</a>
</li>
<li><a href="https://fr.wikipedia.org/wiki/Advanced_Vector_Extensions">https://fr.wikipedia.org/wiki/Advanced_Vector_Extensions</a> 
</li>
<li><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/</a>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Option-Summary.html#Option-Summary">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Option-Summary.html#Option-Summary</a>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Optimize-Options.html#Optimize-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Optimize-Options.html#Optimize-Options</a>
</li>
<li><a href="https://www.nas.nasa.gov/assets/npb/NPB3.4.1-MZ.tar.gz">https://www.nas.nasa.gov/assets/npb/NPB3.4.1-MZ.tar.gz</a>
</li>
<li><a href="https://asc.llnl.gov/sites/asc/files/2020-09/haccmk.zip">https://asc.llnl.gov/sites/asc/files/2020-09/haccmk.zip</a>
</li>
<li><a href="https://github.com/QMCPACK/miniqmc">https://github.com/QMCPACK/miniqmc</a>
</li>
<li><a href="https://github.com/QMCPACK/miniqmc.git">https://github.com/QMCPACK/miniqmc.git</a>
</li>
<li><a href="https://fr.wikipedia.org/wiki/Multiply-accumulate">https://fr.wikipedia.org/wiki/Multiply-accumulate</a>
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Akli HAMITOUCHE - Amar HENNI - Amayas OUAKED - Imane KHELOUAT - Salem Aghiles BRAI</p>
<p class="date">Created: 2021-01-18 lun. 02:28</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
